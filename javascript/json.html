<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>JavaScript json 对象</title>
</head>
<body>

    <script>
        window.onload = function () {

            // javascript 的对象是一种无序的集合数据类型，它由若干键值对组成
            // JavaScript 用一个 {...} 表示一个对象， 键值对以 xxx:xxx 形式声明，用 , 号隔开，最后一个键值末尾后不要加 , 号， 如果加了有的浏览器会报错(如低版本的IE)

            var xiaoming = {
                name: '小明',
                age: 20,
                birth: 1993,
                school: 'No.1 Middle school'
            };
            xiaoming.name;      // 小明
            xiaoming.age;       // 20            
            // 如何获取小明的属性，访问属性是通过 . 操作符完成的。但是这要求属性名必须是一个有效的变量名，如属性名包含特殊字符，就必须用 '' 括起来：

            var xiaohong = {
                name: '小红',
                'middle-school': 'No.1 Middle school'       //现在一般都是驼峰命名法，"-"：一来是特殊字符，二来它还能占位   middleSchool    xiaohong.middleScholl   --  'No.1 Middle school'
            };
            // xiaohong的属性名 middle-school 不是一个有效的变量名，就需要用 '' 括起来, 访问这个属性也无法使用 . 操作符， 必须用 ['XXX']来访问
            xiaohong['middle-school'];     //  No.1 Middle school
            xiaohong['name'];      //  xiaohong['name']  ===  xiahong.name      ===>>> 小红

            // 如果访问一个不存在的属性会返回什么，在JavaScript中规定，访问不存在的属性不报错，返回 undefined
            xiaohong.age;       // undefined

            // 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：
            var xiaobai = {
                name: '小白'
            };
            xiaobai.age;            // undefined
            xiaobai.age = 18;       // 新增一个 age 属性
            xiaobai.age;            // 18
            delete xiaobai.age;     // 删除 age 属性
            delete xiaobai['name'];     // 删除 name 属性       返回 true
            xiaobai.name;       // undefined
            delete xiaobai.school;      // 删除一个不存在的school属性也不会报错，竟然也是返回 true

            // 如果要检测 xiaoming 是否拥有某一属性，可以用 in 操作符：
            'name' in xiaoming;     // true
            'nothing' in xiaoming;  // false

            // 不过要小心， 如果 in 判断一个属性存在，这个属性不一定是 xiaoming 的， 它可能是 xiaoming 继承得到的
            'toString' in xiaoming;     // true
            // 因为 toString 定义在 Object 对象中，而所有对象最终都会在原型链上指向 Object ， 所以 xiaoming 也拥有 toString 属性
            // 要判断一个属性是否是 xiaoming 自身拥有的，而不是继承的得到的，可以用 hasOwnProperty() 方法：
            xiaoming.hasOwnProperty('name');        // true
            xiaoming.hasOwnProperty('toString');    // false


            // 在一个对象中绑定函数，称为这个对象的方法：
            var xiaoHei = {
                name: '小黑',
                birth: 2000,
                age: function(){
                    var y = new Date().getFullYear();
                    return y - this.birth;
                }
            };
            xiaoHei.age;        // function (){ ... }
            xiaoHei.age();      // 19
            // 绑定在对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个 this 关键字 ， 这是啥东东？
            // 在一个方法内部，this 是一个特殊变量， 它始终指向当前对象，也就是 xiaoHei 这个变量， 所以 this.birth 也可以拿到 xiaoHei 的 birth 属性

            function getAge(){
                var y = new Date().getFullYear();
                return y - this.birth;
            };
            function getAges(n){
                var y = new Date().getFullYear();
                return y - n;
            };
            var xiaoHei = {
                name: '小黑',
                birth: 2000,
                age: getAge
            };
            xiaoHei.age();      // 19    正确结果
            getAge();       // NaN  不是一个数字

            // 要保证 this 指向正确，必须使用 obj.xxx() 的形式调用
            // 谁调用 this 就指向谁，单独调用的话，该函数的 this 指向全局对象，也就是 window

            // apply
            // 虽然在一个独立的函数调用中，根据是否 strict 模式，this 指向 undefined 和 window ，不过我们都是可以控制 this 指向的
            // 要指定函数的 this 指向哪个对象，可以用函数本身的 apply 方法 ， 它接收两个参数，第一个参数就是需要绑定的 this 变量 ， 第二个参数就是 Array ，表示函数本身的参数

            getAge.apply(xiaoHei, []);  // 19  this 指向 xiaoHei , 参数为空
            getAges.apply(xiaoHei, [2001]);     // 18  this 指向 xiaoHei , 参数为 [2001]

            // 另一个与 apply() 类似的方法是 call() , 唯一的区别是：
                // apply() 把参数打包成 Array 再传入
                // call()  把参数按顺序传入
            // 比如调用 Math.max(3,5,4) , 分别用 apply() 和 call() 实现如下：
                // Math.max.apply(null, [3,5,4]);      // 5
                // Math.max.call(null, 3,5,4);         // 5
            // 对普通函数调用，我们通常把 this 绑定为 null


            // 高阶函数
            // 高阶函数英文名叫  Higher-order function  , 那什么是高阶函数?
            // JavaScript的函数其实指向某个变量。既然变量可以指向函数，函数的参数可以接收 变量 ， 那么一个函数就可以接收另一个函数作为参数，这种函数就称为 高阶函数
            // 例如：
                function add(x,y,f){
                    return f(x) + f(y);
                };
                add(-5,6,Math.abs);     // 11

                function toStr(a,b,c){
                    return c(a) + c(b);
                };
                function str(a){
                    return a.toString();
                };
                toStr(1,-5,str);    // 1-5

            // map/reduce
            // 由于 map() 方法定义在 JavaScript 的 Array 中，我们调用 Array 的 map() 方法，传入我们自己的函数，得到一个新的 Array 作为结果
            
            function pow(x){
                return x * x;
            };
            var arr = [1,2,3,4,5,6,7,8,9];
            var results = arr.map(pow);     // [1, 4, 9, 16, 25, 36, 49, 64, 81]
            // 注意：map()传入的参数是pow，即函数对象本身
            // 所以，map()作为高阶函数，事实上它把运算规则抽象了

        }    
    </script>
    
</body>
</html>